const swFolder=location.pathname.replace(/[^\/]+\.js$/,""),indexUrl=location.origin+swFolder,urlRoot=location.origin+"/",CACHE_NAME="react-cache",esmshQueryConfigs={target:"es2018","no-dts":!0,sourcemap:!1,pin:"v95"};indexUrl.includes("localhost")&&(esmshQueryConfigs.dev=!0);const pathMap={cdn:{react:{url:"https://esm.sh/react@18.2.0",query:esmshQueryConfigs},"react-dom":{url:"https://esm.sh/react-dom@18.2.0",query:{...esmshQueryConfigs,deps:"react@18.2.0"}},"flex-box":"https://cdn.jsdelivr.net/gh/muggy8/flex-box@f1c7d23fad7ece8fc7538b152ac393a29b65669b","mmc-3":"https://cdn.jsdelivr.net/gh/muggy8/mmc-3@374aa14106e6133f758cf68f2cb9e35b5392cfe5",fitty:{url:"https://esm.sh/fitty@2.3.6",query:esmshQueryConfigs},setimmediate:{url:"https://esm.sh/setimmediate@1.0.5",query:esmshQueryConfigs},"fast-average-color":{url:"https://esm.sh/fast-average-color@9.1.1",query:esmshQueryConfigs},"save-svg-as-png":{url:"https://esm.sh/save-svg-as-png@1.4.17",query:esmshQueryConfigs},gesto:{url:"https://esm.sh/gesto@1.13.3",query:esmshQueryConfigs},"react-input-range":{url:"https://esm.sh/react-input-range@1.3.0",query:esmshQueryConfigs},"react-contextmenu":{url:"https://esm.sh/react-contextmenu@2.14.0",query:esmshQueryConfigs},"react-use-pwa-install":{url:"https://esm.sh/react-use-pwa-install@0.2.1",query:esmshQueryConfigs}},App:indexUrl+"app",Views:indexUrl+"app/views",Utils:indexUrl+"app/utils",Components:indexUrl+"app/components",Assets:indexUrl+"app/assets"};self.addEventListener("install",(function(e){e.waitUntil(Promise.all([self.skipWaiting(),intelegentFetch(indexUrl)]).then(migrateDataFromVersion1To2))})),self.addEventListener("activate",(function(e){e.waitUntil(clients.claim())}));const cacheLocation="cards",settingsLocation="settings",cardListPath="pseudo-api/card-list/",cardDataPath="pseudo-api/card/",settingsPath="pseudo-api/settings/";async function saveSettings(e,t){let s=await e.text(),a=await caches.open("settings"),n=new Response(s,{"Content-Type":"application/json",status:200});return await a.put(t,n.clone()),n}async function getSettings(e,t){let s=await caches.open("settings"),a=await s.match(t);return a||new Response("{}",{"Content-Type":"application/json",status:200})}async function saveData(e,t){let s=await e.text(),a=await caches.open("cards"),n=new Response(s,{"Content-Type":"application/json",status:200});return await a.put(t,n.clone()),n}async function getSavedCard(e,t){let s=await caches.open("cards"),a=await s.match(t);if(a){t.url&&(t=t.url);const[e,s]=t.match(cardIdFinderRegex);let n=await a.json();return n.id=s,new Response(JSON.stringify(n),{"Content-Type":"application/json",status:200})}return new Response("{}",{"Content-Type":"application/json",status:200})}self.addEventListener("fetch",(function(e){const t=e.request.url.replace(urlRoot,""),s=e.request.url.replace(indexUrl,"")||indexUrl,a=remapUrl(t);if(console.log({indexUrl:indexUrl,urlRoot:urlRoot,filePathRelativeToURLRoot:t,filePathRelativeToInstallPath:s,fetchUrl:a}),a)if(t.startsWith("pseudo-api")){let s=!1;"POST"===e.request.method||"PUT"===e.request.method?(t.includes(cardDataPath)&&(e.respondWith(saveData(e.request,t)),s=!0),t.includes(settingsPath)&&(e.respondWith(saveSettings(e.request,t)),s=!0)):"GET"===e.request.method?t.includes(cardListPath)?(e.respondWith(getSavedCardList(e.request,t)),s=!0):t.includes(cardDataPath)?(e.respondWith(getSavedCard(e.request,t)),s=!0):t.includes(settingsPath)&&(e.respondWith(getSettings(e.request,t)),s=!0):"DEL"===e.request.method&&t.includes(cardDataPath)&&(e.respondWith(deleteSavedCard(e.request,t)),s=!0),!s&&e.respondWith(new Response("Not found",{"Content-Type":"text/plain",status:404}))}else a===t?e.respondWith(intelegentFetch(s)):e.respondWith(intelegentFetch(a,t.startsWith("cdn")));else e.respondWith(intelegentFetch(e.request))}));const cardIdFinderRegex=/\/([^\/]+)\/?$/;async function getSavedCardList(e,t){let s=await caches.open("cards"),a=(await s.keys()).filter(e=>e.url.includes(cardDataPath)).map(e=>{let[t,s]=e.url.match(cardIdFinderRegex);return s});a.reverse();let n=a.map(async e=>{let t=await getSavedCard(void 0,cardDataPath+e).then(e=>e.json());return t.id=e,t}),r=await Promise.all(n);return new Response(JSON.stringify(r),{"Content-Type":"application/json",status:200})}async function deleteSavedCard(e,t){let s=await caches.open("cards");return await s.delete(t),new Response("{}",{"Content-Type":"application/json",status:200})}function remapUrl(e){const t=walkPathMap(e.split("/"),pathMap);return t||e}function walkPathMap(e,t){if(!e||!e.length||!t)return;const s=e[0],a=e.slice(1),n=t[s];if("string"==typeof n||"object"==typeof n&&"string"==typeof n.url){let e=["string"==typeof n?n:n.url,...a].join("/");if(n.query){let t=Object.keys(n.query).map(e=>`${e}=${n.query[e]}`).join("&");e.endsWith(".css")&&(t+="&css=true"),e=e+"?"+t}return e}return walkPathMap(a,n)}async function intelegentFetch(e,t=!1){let s,a=e.url||e;if(a.includes("://")&&!a.startsWith("http"))return fetch(e);const n=await caches.open(CACHE_NAME);if(t&&(s=await n.match(e),s))return s;if(s=await n.match(e)){let t,a=s.headers.get("etag"),n=s.headers.get("last-modified");try{t=await fetch(e,{method:"HEAD"})}catch(e){return console.warn(e),s}if(t&&t.headers){if(a&&t.headers.get("etag")===a)return s;if(n&&t.headers.get("last-modified")===n)return s}console.log("asset needs refreshing",e)}try{let t=await fetch(e);return t.ok?(await n.put(e,t.clone()),t):s}catch(e){return s}}async function migrateDataFromVersion1To2(){let e=await caches.open("cards"),t=(await e.keys()).filter(e=>e.url.includes(cardListPath));if(!t.length)return;let s={};const a=t.map(async t=>{const[a,n]=t.url.match(cardIdFinderRegex);s[n]=await e.match(t).then(e=>e.json())});await Promise.all(a);const n=Object.keys(s).map(async t=>{const a=s[t].reduce(async(s,a)=>{const n=cardDataPath+a;await s;let r=await getSavedCard(void 0,n).then(e=>e.json());if(r.dataVersion&&r.dataVersion>1)return;r.type=t,r.dataVersion=2,r.rarity&&(r.rarity.includes("gemless")||r.rarity.includes("none"))&&(r.rarity="");const i=new Response(JSON.stringify(r),{"Content-Type":"application/json",status:200});return e.put(n,i)},Promise.resolve());return await a,e.delete(cardListPath+t)});await Promise.all(n)}async function fetchWithTimeout(e,t={}){const{timeout:s=8e3}=t,a=new AbortController,n=setTimeout(()=>a.abort(),s),r=await fetch(e,{...t,signal:a.signal});return clearTimeout(n),r}