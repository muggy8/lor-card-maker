<html>
	<head>
		<title>LoR Card Maker</title>
		<meta name="description" content="An open source and mobile-friendly web based Card Maker application for the Legends of Runeterra digital CCG. Supports Followers, Champions (level 1 - 3), Spells, Landmarks, Keywords, and Multi-Region."/>
		<meta name="author" content="Muggy Ate"/>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<meta charset="utf-8"/>
		<meta name="language" content="english"/>
		<meta name=”robots” content=”index, follow”/>

		<meta property="og:type" content="website" />
		<meta property="og:title" content="LoR Card Maker" />
		<meta property="og:description" content="An open source and mobile-friendly web based Card Maker application for the Legends of Runeterra digital CCG. Supports Followers, Champions (level 1 - 3), Spells, Landmarks, Keywords, and Multi-Region." />
		<meta property="og:image" content="./ms-icon-310x310.png" />
		<meta property="og:url" content="https://muggy8.github.io/lor-card-maker/" />
		<meta property="og:site_name" content="LoR Card Maker" />

		<meta name="format-detection" content="telephone=no"/>
		<meta name="HandheldFriendly" content="true"/>
		<meta name="viewport" content="width=device-width, initial-scale=1.0"/>

		<meta http-equiv="Content-Style-Type" content="text/css">
		<meta http-equiv="Content-Script-Type" content="text/javascript">


		<style>
			/* inlined css to show loading state */
			html {
				--color-white: #fff;
				--color-black: #000;
				--color-primary: #452abc;
				--color-dark: #444;
				--color-light: #bbb;
				--color-clear: rgba(0,0,0,0);

				--color-bg: var(--color-white);
				--color-text: var(--color-black);
				--color-link: var(--color-primary);
				--color-border: var(--color-dark);
			}

			body, html{
				font-family: sans-serif;
				padding: 0;
				margin: 0;
				background-color: var(--color-bg);
				color: var(--color-text);
				min-height: 100vh;
				width: 100%;
				position: relative;
				z-index: -9001;
			}

			a {
				color: var(--color-link);
			}

			body.loading::before, body.loading::after {
				display: block;
				content: " ";
				position: absolute;
				top: 50%;
				left: 50%;
				transform: translate(-50%, -50%);
			}

			body.loading::before {
				width: 10vw;
				height: 10vw;
				top: calc(50% - max(5vw, 5vh));
				left: calc(50% - max(5vw, 5vh));
				transform: initial;
				border-radius: calc(max(2vw, 2vh) + max(5vw, 5vh));
				border-width: max(2vw, 2vh);
				border-color: var(--color-clear);
				border-top-color: var(--color-primary);
				border-style: solid;
				animation-name: spin;
				animation-duration: 1.5s;
				animation-timing-function: linear;
				animation-iteration-count: infinite;
			}

			@keyframes spin {
				0% {
					transform: rotate(0deg);
				}
				100% {
					transform: rotate(360deg);
				}
			}

		</style>
		<script defer type="module">
			if ('serviceWorker' in navigator) {
				navigator.serviceWorker.register('./service-worker.js', {
					scope: document.location.pathname,
				})
					.then(async function(registration) {
						// console.log('Registration successful:', registration)

						// check for worker update because we dont want to load anything until the worker is known to be the latest worker.
						const updatedRegistration = await registration.update()

						// if the updatedRegistration has something in the installing prop, we know that we found an update so we will want to wait for it to finish it's install and activate process before we continue.
						if (updatedRegistration.installing || updatedRegistration.active.state !== "activated"){
							return await new Promise((accept)=>{
								updatedRegistration.installing.addEventListener("statechange", ev=>{
									// console.log(ev)
									if (ev.target.state === "activated"){
										accept(updatedRegistration)
									}
								})
							})
						}

						return updatedRegistration
					})
					.then(async function(){
						// at this point, we know that the service worker has been registered and is active. that means we can use ESM to import our main app and we'll let the service worker figure out how to fulfill the import requests
						const indexUrl = "/App/index.js"
						for (let i = 0; i < 3; i++){
							try {
								const res = await fetch(indexUrl)
								if (res.status < 300){
									return indexUrl
								}
							} catch (err) {
								console.error(err)
							}

							await new Promise(accept=>{
								setTimeout(accept, Math.floor(Math.random() * 100) + (500 * i))
							})
						}
						window.document.location.reload()
					})
					.then((url)=>{
						return import(url)
					})
					.catch(function(error) {
						console.log('Service worker registration failed, error:', error);
					});
			}
		</script>
	</head>
	<body class="loading">
		<section id="app"></section>
	</body>
</html>
